#!/usr/bin/env perl
use Mail::Internet;
use Data::Dumper;
use Time::Piece;
use FileHandle;
use strict;

package USNEasy;
use strict;
# use warnings;

sub new{
  my $class = shift;
  my $usn = shift;
  my $self = {};
  $self->{'debug'} = 0;
  $self->{'notice'} = $usn;
  $self->{'begins_with'} = {
                             'header'              => '^=+$',
                             'affects'             => '^(A security issue affects these releases of Ubuntu and its derivatives|A security issue affects the following Ubuntu releases):',
                             'summary'             => '^(Summary):',
                             'description'         => '^(Software Description):',
                             'details'             => '^(Details|Details (F|f)ollow):',
                             'update_instructions' => '^(Update (I|i)nstructions):',
                             'references'          => '^(References):',
                             'package_information' => '^(Package Information):',
                             'next_part'           => '^-+ next part -+$',
                           };
  bless $self, $class;
  return $self;
}

sub any_section_header{
  my $self = shift;
  my @regexes;
  foreach my $key (sort(keys(%{$self->{'begins_with'}}))){
    push(@regexes,$self->{'begins_with'}->{$key});
  }
  return "(".join('|',@regexes).")";
}

sub notice{
  my $self = shift;
  $self->{'notice'} = shift if @_;
  return $self->{'notice'};
}

# A section will be defined as the section header, until the start of any next section.
sub section{
  my $self = shift;
  my $type = shift;
  return $self->{$type} if defined($self->{$type});
  return undef unless(defined($self->{'begins_with'}->{$type}));
  my $in_section=0;
  my $has_section=0;
  my $section=[];
  my $stop_regex = $self->any_section_header;
  foreach my $line (split/\n/,$self->notice){
      if($line=~m/$self->{'begins_with'}->{$type}/){
         if ($in_section==0){
             $has_section=1;
             $in_section = 1;
         }else{
             $in_section = 0;
         }
      }elsif($line=~m/$stop_regex/){
        $in_section = 0 if ($in_section==1);
      }
      if($in_section == 1){
        if($in_section == 1){
           push(@{$section},$line) unless( ($type == 'header') && ($line=~m/$self->{'begins_with'}->{$type}/) );
        }
        if($self->{'debug'} > 0){
          if( ($type == 'header') && ($line=~m/$self->{'begins_with'}->{$type}/) ){
            print ":OUT: ".$line."\n";
          }else{
            print ": IN: ".$line."\n";
          }
        }
      }else{
        print ":OUT: ".$line."\n" if $self->{'debug'} > 0;
      }

  }
  return undef unless $has_section;
  $self->{$type} = join("\n",@{$section});
  return $self->{$type};
}

sub header{              my $self=shift; return $self->section('header');              }
sub affects{             my $self=shift; return $self->section('affects');             }
sub summary{             my $self=shift; return $self->section('summary');             }
sub description{         my $self=shift; return $self->section('description');         }
sub details{             my $self=shift; return $self->section('details');             }
sub update_instructions{ my $self=shift; return $self->section('update_instructions'); }
sub references{          my $self=shift; return $self->section('references');          }
sub package_information{ my $self=shift; return $self->section('package_information'); }
sub next_part{           my $self=shift; return $self->section('next_part');           }

sub has_header{ my $self=shift; return 1 if defined($self->header); return 0; }
sub has_affects{ my $self=shift; return 1 if defined($self->affects); return 0; }
sub has_summary{ my $self=shift; return 1 if defined($self->summary); return 0; }
sub has_description{ my $self=shift; return 1 if defined($self->description); return 0; }
sub has_details{ my $self=shift; return 1 if defined($self->details); return 0; }
sub has_update_instructions{ my $self=shift; return 1 if defined($self->update_instructions); return 0; }
sub has_references{ my $self=shift; return 1 if defined($self->references); return 0; }
sub has_package_information{ my $self=shift; return 1 if defined($self->package_information); return 0; }
sub has_next_part{ my $self=shift; return 1 if defined($self->next_part); return 0; }

1;

my $directory = $ARGV[0];
opendir(my $dh, $directory);
my @mboxes = sort_mboxes(grep { /.txt$/ && -f "$directory/$_" } readdir($dh));
closedir $dh;
# print Data::Dumper->Dump([@mboxes]);
my $mails = [];
my $current_mail = [];

foreach my $mbox (@mboxes){
    my $fh = FileHandle->new("${directory}/$mbox", "r");
        if (defined $fh) {
            while( my $line=<$fh> ){
              if($line=~m/^From /){
                push(@{$mails},Mail::Internet->new( $current_mail )) if $#{$current_mail} > 0;
                $current_mail = [];
              }
              push(@{$current_mail}, $line);
            }
            undef $fh;       # automatically closes the file
        }
}
foreach my $mail (@{$mails}){
    my $notice = USNEasy->new(join('',@{$mail->body}));
    $notice->has_header?print "H":print"_";
    $notice->has_affects?print "A":print"_";
    $notice->has_summary?print "S":print"_";
    $notice->has_description?print "D":print"_";
    $notice->has_details?print "E":print"_";
    $notice->has_update_instructions?print "U":print"_";
    $notice->has_references?print "R":print"_";
    $notice->has_package_information?print "P":print"_";
    $notice->has_next_part?print "N":print"_";
    print "\n";

    print $notice->notice unless $notice->has_header;
    # print $notice->section('description')."\n";
    # print $notice->section('details')."\n";
}
exit 0;

################################################################################
sub sort_mboxes(){
    my @mailboxes = @_;
    my $idx = { 'January'   => '01', 'February'  => '02', 'March'     => '03',
                'April'     => '04', 'May'       => '05', 'June'      => '06',
                'July'      => '07', 'August'    => '08', 'September' => '09',
                'October'   => '10', 'November'  => '11', 'December'  => '12' };
    my $ridx = {};
    foreach my $i (keys(%{$idx})){ $ridx->{ $idx->{$i} } = $i; }
    my @numerical_mboxes;
    foreach my $mbox (@mailboxes){
      $mbox=~s/.txt//g;
      if($mbox=~m/-(.*)/){ my $month=$1 ; $mbox=~s/-$month/$idx->{$month}/; }
      push(@numerical_mboxes,$mbox);
    }
    my @result;
    foreach my $mbox ( sort @numerical_mboxes ){
      if($mbox=~m/([0-9]{4})([0-9]{2})/){ push(@result, "$1-$ridx->{$2}.txt"); }
    }
    return @result;
}
